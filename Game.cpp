/*By: Jeremy Melone  Student #: 100969284

Controls:

Left and Right arrows move character
Hold Space uses Bullet Time mode
Enter restarts after you've died

*/

#include <SFML/Graphics.hpp>
#include <SFML/System.hpp>
#include <iostream>
#include <windows.h>
#include <queue>

#include "Game.hpp"

// constructor
Game::Game()
{

	// seeding the random number generator
	std::srand(std::time(0));

	// setting the window / tile dimensions and computing the grid dimensions
	this->winw = 800;
	this->winh = 600;

	// create the window and set framerate limiting
	
	this->window.create(sf::VideoMode(this->winw, this->winh), "Assignment 1");

	//initialize variables
	this->bulletTime = false;//boolean whether or not bullet time is activated
	this->left = 0;//int represents if left if being pressed or not
	this->right = 0;//int represents if right if being pressed or not
	this->charPos = winw / 2;//int character's x position
	this->charVel = 0;//int character's x velocity
	this->playerDead = false;//boolean whether player is dead or not
	this->btLength = BULLET_TIME_LENGTH;//int how long bullettime will last for
	this->score = 0;//unsigned int keeps tally of score

	//enemies
	for (int i = 0; i < 20; i++) {
		this->enemies[i].y = 0 - (this->winh * (i % 10) / 10);
		this->enemies[i].x = rand() % (winw - 50);
	}
}

// destructor
Game::~Game()
{ }

// game loop
void Game::loop()
{
	//total fps of last 10 frames
	int fpsTotal = 0;

	//stores last 10 frames fps
	std::queue<float> fpsQueue;

	//constant desired length of each frame
	const float desiredframetime = 12.f;

	//times the frames
	sf::Clock clock;
	float time = 0;
	float timebeforesleep = 0;

	while (this->window.isOpen())//loop
	{
		//gets time that has passed
		time = clock.getElapsedTime().asMilliseconds();
		//std::cout << "Time = " << time << std::endl;

		//restarts clock
		clock.restart();

		//gets imputs
		inputs();

		//adds the newest time to the fps counter
		if (time != 0) {
			fpsTotal += time;
			fpsQueue.push(time);
		}

		//pops oldest fps from queue
		if (fpsQueue.size() > 10) {
			fpsTotal -= fpsQueue.front();
			fpsQueue.pop();
		}

		//prints fps to the console
		if (fpsQueue.size() != 0) {
			std::cout << "FPS = " << fpsQueue.size() * 1000 / (fpsTotal) << std::endl;
		}

		//updates game by delta time
		update(time);

		//renders the screen
		render();

		//frame limiting
		timebeforesleep = clock.getElapsedTime().asMilliseconds();
		//std::cout << "TimeBeforeSleep = " << timebeforesleep << std::endl;

		if (timebeforesleep < desiredframetime) {
			Sleep(desiredframetime - timebeforesleep);
			//std::cout << "Sleep for = " << (desiredframetime - timebeforesleep) << std::endl;
		}
	}
}

// retrieve and process input
void Game::inputs() {

	sf::Event event;

	// consider each event generated by the window
	while (window.pollEvent(event))
	{

		switch (event.type)
		{
			// if the event is the window close button being clicked, close the window
		case sf::Event::Closed:
			window.close();
			break;

		}

	}
	//return pressed
	if (sf::Keyboard::isKeyPressed(sf::Keyboard::Return) && this->playerDead == true) {
		this->playerDead = false;
		this->score = 0;
	}
	//left pressed
	if(sf::Keyboard::isKeyPressed(sf::Keyboard::Left)) {
		this->left = 1;
	} else {
		this->left = 0;
	}
	//right pressed
	if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right)) {
		this->right = 1;
	} else {
		this->right = 0;
	}
	//space pressed
	if (sf::Keyboard::isKeyPressed(sf::Keyboard::Space)) {
		this->bulletTime = true;
	} else {
		this->bulletTime = false;
	}
	//escape pressed
	if (sf::Keyboard::isKeyPressed(sf::Keyboard::Escape)) {
		window.close();
	}
	
}


// update the internal representation of the game world
void Game::update(int time) {

	//set bulletFactor to 30 if bulletTime is true
	int bulletFactor = 10;
	if (this->bulletTime && this->btLength > 0) {
		bulletFactor = 30;
		this->btLength -= time;
	}
	//increases bullet time when it isnt active
	else if (!this->bulletTime && btLength < 5000) {
		btLength += time / 2;
	}
	//keeps the length between 0 and 5000
	if (btLength > BULLET_TIME_LENGTH) btLength = BULLET_TIME_LENGTH;
	if (btLength < 0) btLength = 0;

	//update score
	if (!this->playerDead) this->score += time * 2 / bulletFactor;

	if (this->playerDead) {
		//initialize variables
		this->bulletTime = false;
		this->left = 0;
		this->right = 0;
		this->charPos = winw / 2;
		this->charVel = 0;
		this->btLength = BULLET_TIME_LENGTH;

		//enemies
		for (int i = 0; i < 10; i++) {
			this->enemies[i].y = 0 - (this->winh*i / 10);
			this->enemies[i].x = rand() % (winw - 50);
			this->enemies[i+10].y = 0 - (this->winh*i / 10);
			this->enemies[i+10].x = rand() % (winw - 50);
		}

	} else {

		// if left is being held
		if (this->left == 1 && this->right == 0) {
			this->charVel -= 1;

		// if right is being held
		}
		else if (this->right == 1 && this->left == 0) {
			this->charVel += 1;

		//if both or neither are being held
		}
		else {
			if (this->charVel > 0) this->charVel -= 1;
			else if (this->charVel < 0) this->charVel += 1;
		}

		//caps the velocity at MAX_VEL

		if (this->charVel > MAX_VEL) this->charVel = MAX_VEL;
		if (this->charVel < -1 * MAX_VEL) this->charVel = -1 * MAX_VEL;

		//moves the character based on the time interval and whether or not bullet time is activated
		this->charPos += (this->charVel * time / bulletFactor);

		//keeps the character within the screen's bounds
		if (this->charPos < 0) this->charPos = 0;
		if (this->charPos > this->winw - 50) this->charPos = winw - 50;

		// enemies falling

		for (int i = 0; i < 20; i++) {

			//includes bullet time if necessary
			this->enemies[i].y += ENEMY_FALL_SPEED * 10 / bulletFactor;
			
			//puts the enemies to the top at random x positions when they reach the bottom
			if (this->enemies[i].y > this->winh) {
				this->enemies[i].x = rand() % (this->winw - 50);
				this->enemies[i].y -= this->winh;
			}
		}

		//enemy collision
		for (int i = 0; i < 20; i++) {
			if (this->enemies[i].y >= this->winh - 110 && this->enemies[i].y <= this->winh - 10 &&
				this->enemies[i].x <= this->charPos + 50 && this->enemies[i].x >= this->charPos - 50) {
				this->playerDead = true;
				break;
			}

		}


	}


}

// render the visual representation of the world
void Game::render() {

	//if the player is dead
	if (this->playerDead) {
		// clear the window
		this->window.clear(sf::Color::White);

		//game over screen
		sf::Font font;
		font.loadFromFile("arial.ttf");

		sf::Text text;
		text.setFont(font);
		text.setCharacterSize(20);
		text.setColor(sf::Color::Green);
		text.setPosition(20, this->winh/2);
		text.setString("You lose! Press Enter to play again! Your score was: " + std::to_string(this->score));
		this->window.draw(text);

		
	} else {//if the player is alive

		// clear the window
		this->window.clear(sf::Color::White);

		//player
		sf::RectangleShape rectangle;
		rectangle.setFillColor(sf::Color::Blue);
		rectangle.setSize(sf::Vector2f(50, 50));
		rectangle.setPosition(this->charPos, this->winh - 60);
		this->window.draw(rectangle);

		//enemies
		for (int i = 0; i < 20; i++) {
			sf::RectangleShape enemy;
			enemy.setFillColor(sf::Color::Red);
			enemy.setSize(sf::Vector2f(50, 50));
			enemy.setPosition(this->enemies[i].x, this->enemies[i].y);
			this->window.draw(enemy);

		}

		//font
		sf::Font font;
		font.loadFromFile("arial.ttf");

		//show score
		sf::Text text;
		text.setFont(font);
		text.setCharacterSize(25);
		text.setColor(sf::Color::Green);
		text.setPosition(20, this->winh - 30);
		text.setString("Score: " + std::to_string(this->score));
		this->window.draw(text);

		//bullettime meter
		sf::RectangleShape meter;
		meter.setFillColor(sf::Color::Green);
		meter.setSize(sf::Vector2f(200 * this->btLength / BULLET_TIME_LENGTH, 20));
		meter.setPosition(10, 10);
		this->window.draw(meter);
	}
	// display the window
	this->window.display();

}
